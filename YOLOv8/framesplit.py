# -*- coding: utf-8 -*-
"""framesplit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PQIbDhhvewlByFOTO_VfBQ7dsNGYvUIK
"""

import os
import cv2
import numpy as np
import pandas as pd
from tqdm import tqdm
from zipfile import ZipFile
from sklearn.model_selection import train_test_split

from google.colab import drive
drive.mount('/content/drive')

# Define paths
zip_dir = "/content/drive/MyDrive/CarCrash/videos"
output_dir = "/content/drive/MyDrive/CarCrashYOLO/images"

# Function to generate training and testing data split
def generate_train_test_split(test_size=0.3):
    # Generate file names with the respective positive or negative prefixes
    positive_files = [f"{i:06d}.mp4" for i in range(1, 1501)]
    negative_files = [f"{i:06d}.mp4" for i in range(1501, 3001)]

    # Combine positive and negative files
    all_files = positive_files + negative_files
    labels = [1] * len(positive_files) + [0] * len(negative_files)  # 1 for positive, 0 for negative

    # Split the data into training and testing sets
    train_files, test_files, y_train, y_test = train_test_split(all_files, labels, test_size=test_size, stratify=labels)

    # Return the filenames for training and testing sets
    return train_files, test_files, y_train, y_test

    # Function to extract videos from a ZIP file
def extract_videos(zip_path, folder_name, start_index=None, end_index=None):
    with ZipFile(zip_path, 'r') as zip_ref:
        # Extract videos in the specified range
        for i in range(1, 3001):
            video_name = f"{i:06d}.mp4"
            if (start_index is None or i >= start_index) and (end_index is None or i <= end_index):
                zip_ref.extract(video_name, folder_name)

# Function to save frames as jpg
def save_frames(files, output_folder, split_type):
    for file in tqdm(files):
        video_path = os.path.join("videos", file)
        video_name = os.path.splitext(file)[0]
        save_folder = os.path.join(output_folder, split_type)

        # Open the video file
        cap = cv2.VideoCapture(video_path)

        # Get the number of frames
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

        # Read and save each frame
        for frame_num in range(1, 51):
            ret, frame = cap.read()
            if not ret:
                break

            frame_filename = f"{video_name}_{frame_num}.jpg"
            frame_path = os.path.join(save_folder, frame_filename)
            cv2.imwrite(frame_path, frame)

        cap.release()

# Function to create DataFrame with information
def create_dataframe(image_folder):
    data = []

    for split_type in ["train", "test"]:
        folder_path = os.path.join(image_folder, split_type)

        for video_name in tqdm(os.listdir(folder_path)):
            video_id, _ = os.path.splitext(video_name)
            video_id, frame_num = video_id.split('_')
            frame_num = int(frame_num)

            data.append([video_id, split_type, frame_num])

    columns = ["Video_ID", "Split_Type", "Frame_Num"]
    df = pd.DataFrame(data, columns=columns)

    return df

# Function to generate training and testing data split for video frames
def generate_video_frame_split(zip_path_pos, zip_path_neg, test_size=0.3):
    # Extract videos from ZIP files
    extract_videos(zip_path_pos, "videos", end_index=1500)
    extract_videos(zip_path_neg, "videos", start_index=1501, end_index=3000)

    # Generate train-test split for video frames
    train_files, test_files, y_train, y_test = generate_train_test_split(test_size)

    # Process and save frames for train and test videos
    save_frames(train_files, output_dir, "train")
    save_frames(test_files, output_dir, "test")

    # Create DataFrame with information
    df = create_dataframe(output_dir)

    return df

zip_path_pos = "/content/drive/MyDrive/CarCrash/videos/Crash-1500.zip"
zip_path_neg = "/content/drive/MyDrive/CarCrash/videos/Normal.zip"

df = generate_video_frame_split(zip_path_pos, zip_path_neg, test_size=0.3)
df.head()

df

df['Split_Type'].value_counts()

df.to_csv("/content/drive/MyDrive/CarCrashYOLO/df.csv", index=False)

data = np.load('/content/drive/MyDrive/CarCrash/vgg16_features/positive/000001.npz')
data['labels']

df = df.sort_values(by=['Video_ID', 'Frame_Num'])
df['Video_ID_int'] = df['Video_ID'].astype(int)
df

with open('/content/drive/MyDrive/CarCrash/videos/Crash-1500.txt', 'r') as file:
    lines = file.readlines()
len(lines)

import re
match = re.search(r'\[.*?\]', lines[0])
extracted_list = eval(match.group())
extracted_list

# assign frame label for each frame
for index, row in df.iterrows():
    if row['Video_ID_int'] <= 1500:
        video_index = row['Video_ID_int'] - 1

        match = re.search(r'\[.*?\]', lines[video_index])
        extracted_list = eval(match.group())

        frame_index = int(row['Frame_Num']) - 1
        df.at[index, 'label'] = extracted_list[frame_index]

    else:
        df.at[index, 'label'] = 0

df['label'] = df['label'].astype(int)
df['label'].value_counts()

data = np.load('/content/drive/MyDrive/CarCrash/vgg16_features/positive/000001.npz')
data['det'][0]

def calculate_bbox_properties(x1, y1, x2, y2):
    c1 = (x1 + x2) / 2
    c2 = (y1 + y2) / 2
    h = abs(y2 - y1)
    w = abs(x2 - x1)